---
title: Python Data Types
description: Python is a dynamically typed language, meaning variables do not require explicit type declarations. Python provides a variety of built-in data types to handle different kinds of data, from numbers to complex collections. These data types are the building blocks of Python programming and interact with operators in unique ways.
navigation:
  icon: i-lucide-book-text
---

## Overview of Built-in Data Types

Python’s primary built-in data types can be categorized as follows:

1. **Numeric Types**: `int`, `float`, `complex`
2. **Boolean Type**: `bool`
3. **Sequence Types**: `str`, `list`, `tuple`
4. **Set Type**: `set`
5. **Mapping Type**: `dict`
6. **None Type**: `NoneType`

---

# Numbers

### Learning Outcomes

By the end of this section, students will be able to:

- Identify and create the three types of numbers in Python: integers, floats, and complex numbers.
- Apply arithmetic, comparison, assignment, and bitwise operators to perform operations on numbers.
- Convert between number types using int(), float(), and complex() functions.
- Use built-in number functions like abs(), round(), min(), and max() for common tasks.
- Understand the precision limitations of floats and how they affect computations.

## Python Numbers

Numbers in Python are used to represent numerical values and come in three main types: integers (`int`), floating-point numbers (`float`), and complex numbers (`complex`). Python provides robust support for arithmetic operations and conversions between these types, making it a powerful tool for numerical computations.

### Types of Numbers

1. **Integers (`int`)**

   - Whole numbers without a decimal point.
   - Unlimited precision in Python (no size limit beyond memory constraints).

   ```sh
   x = 42
   y = -15
   print(type(x))  # Output: <class 'int'>
   ```

2. **Floating-Point Numbers (float)**

   - Numbers with a decimal point or in exponential notation.
   - Used for real numbers with fractional parts.

   ```sh
   a = 3.14
   b = -0.001
   c = 2.5e3  # 2.5 * 10^3 = 2500.0
   print(type(a))  # Output: <class 'float'>
   ```

3. **Complex Numbers (complex)**

   - Numbers with a real and imaginary part, written as a + bj where j is the imaginary unit.
   - Used in scientific and engineering calculations.

   ```sh
   z = 3 + 4j
   w = -2.5 + 1j
   print(type(z))  # Output: <class 'complex'>
   ```

### Creating Numbers

Numbers can be created by directly assigning values or converting from other types using built-in functions like int(), float(), and complex().

```sh
# Direct assignment
integer = 10
floating = 5.67
complex_num = 1 + 2j

# Type conversion
str_num = "123"
converted_int = int(str_num)    # Output: 123
converted_float = float("4.56") # Output: 4.56
converted_complex = complex(3, 2)  # Output: (3+2j)
```

### Number Operators

Python numbers work with many of the operators discussed earlier, particularly arithmetic operators.

1.  Arithmetic Operators
    These perform mathematical operations on numbers.

    ````sh
        x = 10
        y = 3

        print(x + y)   # Addition: 13
        print(x - y)   # Subtraction: 7
        print(x * y)   # Multiplication: 30
        print(x / y)   # Division: 3.333... (returns float)
        print(x // y)  # Floor Division: 3 (integer quotient)
        print(x % y)   # Modulus: 1 (remainder)
        print(x ** y)  # Exponentiation: 1000 (10^3)
        2. Comparison Operators
        Compare numerical values to return a boolean.
        a = 5
        b = 8

        print(a == b)  # False
        print(a != b)  # True
        print(a > b)   # False
        print(a < b)   # True
        print(a >= b)  # False
        print(a <= b)  # True
        3. Assignment Operators
        Modify number values in place.
        x = 5
        x += 3   # x = 8
        x *= 2   # x = 16
        x /= 4   # x = 4.0 (result is float)
        print(x)  # Output: 4.0
        4. Bitwise Operators (Integers Only)
        Operate on the binary representation of integers.
        a = 10  # Binary: 1010
        b = 4   # Binary: 0100

        print(a & b)   # Bitwise AND: 0 (0000)
        print(a | b)   # Bitwise OR: 14 (1110)
        print(a ^ b)   # Bitwise XOR: 14 (1110)
        print(~a)      # Bitwise NOT: -11
        print(a << 2)  # Left Shift: 40 (101000)
        print(a >> 1)  # Right Shift: 5 (0101)
        5. Complex Number Operations
        Complex numbers support addition, subtraction, multiplication, and division.
        z1 = 3 + 4j
        z2 = 1 - 2j

        print(z1 + z2)  # (4 + 2j)
        print(z1 * z2)  # (11 - 2j)```
    ````

### Number Conversions

Python allows easy conversion between number types, though some conversions may lose precision.

```sh
# Integer to float
i = 10
f = float(i)  # 10.0

# Float to integer (truncates decimal)
f = 5.9
i = int(f)    # 5

# Integer/float to complex
c = complex(3, 4)  # 3 + 4j
print(c.real)      # 3.0 (real part)
print(c.imag)      # 4.0 (imaginary part)
```

### Common Number Functions

Python provides several built-in functions for working with numbers. Here are some commonly used ones:

| Function    | Description                                                   | Example                    |
| ----------- | ------------------------------------------------------------- | -------------------------- |
| `abs()`     | Returns the absolute value of a number                        | `abs(-5)` → `5`            |
| `round()`   | Rounds a float to a specified number of digits                | `round(3.567, 1)` → `3.6`  |
| `min()`     | Returns the smallest value from arguments or an iterable      | `min(3, 1, 4)` → `1`       |
| `max()`     | Returns the largest value from arguments or an iterable       | `max(3, 1, 4)` → `4`       |
| `pow()`     | Raises a number to a power (returns float if modulo not used) | `pow(2, 3)` → `8`          |
| `divmod()`  | Returns a tuple of quotient and remainder                     | `divmod(10, 3)` → `(3, 1)` |
| `sum()`     | Sums all numbers in an iterable                               | `sum([1, 2, 3])` → `6`     |
| `int()`     | Converts to an integer (truncates decimals)                   | `int(3.7)` → `3`           |
| `float()`   | Converts to a floating-point number                           | `float("4.5")` → `4.5`     |
| `complex()` | Creates a complex number                                      | `complex(2, 3)` → `(2+3j)` |
| `bin()`     | Converts an integer to a binary string                        | `bin(10)` → `'0b1010'`     |
| `hex()`     | Converts an integer to a hexadecimal string                   | `hex(255)` → `'0xff'`      |
| `oct()`     | Converts an integer to an octal string                        | `oct(8)` → `'0o10'`        |

```sh
Some examples
print(abs(-7.25))      # Output: 7.25
print(round(3.14159, 2))  # Output: 3.14
print(min(5, -2, 10))  # Output: -2
print(max(5, -2, 10))  # Output: 10
print(pow(4, 2))       # Output: 16
```

### Precision and Limitations

Integers: No upper limit (arbitrary precision), constrained only by system memory.
Floats: Follow IEEE 754 standard, with limited precision (approximately 15-17 decimal digits). May lead to rounding errors:

```sh
print(0.1 + 0.2 == 0.3)  # Output: False (due to float imprecision)
print(0.1 + 0.2)         # Output: 0.30000000000000004
Complex: Combines two floats, inheriting their precision limits.
```

---

# Strings

- [Strings](#python-strings)
- [Creating a string](#creating-strings)
- [String Operations](#string-operators)
- [String Indexing and Slicing](#string-indexing-and-slicing)
- [String Immutabilty](#string-immutability)
- [Common string Methods](#common-string-methods)
- [String Formatting](#string-formatting)

### Learning Outcomes

By the end of this section, students will be able to:

- Create strings using different quote types and understand their immutability.
- Apply operators like +, \*, in, and comparison operators to manipulate and test strings.
- Access and extract parts of strings using indexing and slicing techniques.
- Use common string methods to perform tasks like case conversion, splitting, and searching.
- Format strings using %, .format(), and f-strings for dynamic text output.

## Python Strings

Strings in Python are sequences of characters used to represent text. They are immutable, meaning once created, they cannot be changed. Strings are one of the most commonly used data types in Python and can be manipulated using various operators and methods.

### Creating Strings

Strings can be created using single quotes (`'`), double quotes (`"`), or triple quotes (`'''` or `"""`) for multi-line strings.

```sh
# Single and double quotes
single_quote_str = 'Hello'
double_quote_str = "World"
print(single_quote_str)  # Output: Hello
print(double_quote_str)  # Output: World


# Triple quotes for multi-line strings
multi_line_str = '''This is a
multi-line
string'''
print(multi_line_str)

# Output:
# This is a
# multi-line
# string
```

### String Operators

Strings support several operators, many of which overlap with other Python operator categories but have specific behavior with strings.

1. Concatenation (+)
   The + operator joins two or more strings together.

```sh
str1 = "Hello"
str2 = "World"
result = str1 + " " + str2
print(result)  # Output: Hello World
```

2. Repetition (_)
   The _ operator repeats a string a specified number of times.

```sh
str = "Python "
repeated = str * 3
print(repeated)  # Output: Python Python Python
```

3. Membership Operators (in, not in)
   These check if a substring exists within a string.

```sh
text = "Python is awesome"
print("is" in text)       # Output: True
print("java" not in text) # Output: True
print("Python" in text)   # Output: True
```

4. Comparison Operators (==, !=, >, <, >=, <=)
   Strings can be compared lexicographically (based on ASCII/Unicode values).

```sh
str1 = "apple"
str2 = "banana"
print(str1 == str2)  # Output: False
print(str1 < str2)   # Output: True (a comes before b)
print(str1 != str2)  # Output: True
```

### String Indexing and Slicing

Strings are sequences, so you can access individual characters using indexing (0-based) and extract substrings using slicing.

```sh
text = "Python"

# Indexing
print(text[0])   # Output: P
print(text[-1])  # Output: n (negative index from end)

# Slicing [start:stop:step]
print(text[0:2])     # Output: Py (from index 0 to 1)
print(text[2:])      # Output: thon (from index 2 to end)
print(text[::-1])    # Output: nohtyP (reverse string)
```

### String Immutability

Strings cannot be modified in place. Any operation that seems to "change" a string actually creates a new string.

```sh
str = "Hello"
# str[0] = 'h'  # This would raise a TypeError
new_str = "h" + str[1:]
print(new_str)  # Output: hello
```

### Common String Methods

Python provides a rich set of built-in methods for string manipulation. Here are some commonly used ones:

| Method         | Description                              | Example                                  |
| -------------- | ---------------------------------------- | ---------------------------------------- |
| `len()`        | Returns the length of the string         | `len("Python")` → `6`                    |
| `lower()`      | Converts to lowercase                    | `"HELLO".lower()` → `"hello"`            |
| `upper()`      | Converts to uppercase                    | `"hello".upper()` → `"HELLO"`            |
| `strip()`      | Removes leading/trailing whitespace      | `"  hi  ".strip()` → `"hi"`              |
| `replace()`    | Replaces a substring                     | `"cat".replace("c", "b")` → `"bat"`      |
| `split()`      | Splits string into a list by delimiter   | `"a,b,c".split(",")` → `['a', 'b', 'c']` |
| `join()`       | Joins a list of strings with a delimiter | `",".join(['a', 'b'])` → `"a,b"`         |
| `find()`       | Returns index of first occurrence        | `"hello".find("l")` → `2`                |
| `startswith()` | Checks if string starts with substring   | `"hello".startswith("he")` → `True`      |
| `endswith()`   | Checks if string ends with substring     | `"hello".endswith("lo")` → `True`        |

### Examples of String Methods

```sh
text = "  Python Programming  "

# Length
print(len(text))  # Output: 20

# Case conversion
print(text.lower())  # Output:   python programming
print(text.upper())  # Output:   PYTHON PROGRAMMING

# Strip whitespace
print(text.strip())  # Output: Python Programming

# Replace
print(text.replace("Python", "Java"))  # Output:   Java Programming

# Split and join
words = text.split()  # Output: ['Python', 'Programming']
print(",".join(words))  # Output: Python,Programming

# Find
print(text.find("Prog"))  # Output: 9

# Start/end checks
print(text.startswith("  Py"))  # Output: True
print(text.endswith("ing  "))   # Output: True
```

### String Formatting

Python offers multiple ways to format strings:

Using % Operator (Old Style)

```sh
name = "Alice"
age = 25
print("My name is %s and I am %d years old" % (name, age))
# Output: My name is Alice and I am 25 years old
```

Using .format() Method

```sh
print("My name is {} and I am {} years old".format(name, age))
# Output: My name is Alice and I am 25 years old
```

Using f-Strings (Python 3.6+)

```sh
print(f"My name is {name} and I am {age} years old")
# Output: My name is Alice and I am 25 years old
```

---

# Boolean

### Learning Outcomes

By the end of this section, students will be able to:

- Understand the Boolean data type and its two values: True and False.
- Create Booleans using comparison, logical, identity, and membership operators.
- Use the bool() function to convert other data types to Booleans and explain truthiness rules.
- Apply Booleans in control flow structures like if statements and loops.
- Recognize Booleans as integers and perform arithmetic operations with them.

## Python Booleans

Booleans in Python represent one of two values: `True` or `False`. They are a fundamental data type used to express truth values, often resulting from comparisons or logical operations. Booleans are integral to control flow in programming, such as in `if` statements and loops, and are closely tied to operators like comparison and logical operators.

### Boolean Values

Python has two Boolean constants:

- `True`: Represents a true condition or affirmative state.
- `False`: Represents a false condition or negative state.

These values are case-sensitive; the first letter must be capitalized (`True`, not `true`).

```sh
x = True
y = False
print(type(x))  # Output: <class 'bool'>
print(x)        # Output: True
print(y)        # Output: False
```

### Creating Booleans

Booleans are typically created as the result of:

> Comparison Operators: Comparing values yields a Boolean.
> Logical Operators: Combining conditions produces a Boolean.
> Explicit Assignment: Directly assigning True or False.
> Type Conversion: Using the bool() function to convert other types.

Examples of Creation

```sh
# Comparison operators
print(5 > 3)    # Output: True
print(10 == 7)  # Output: False

# Logical operators
print(True and False)  # Output: False

# Explicit assignment
is_active = True
print(is_active)      # Output: True

# Type conversion with bool()
print(bool(1))        # Output: True
print(bool(0))        # Output: False
print(bool(""))       # Output: False
print(bool("hello"))  # Output: True
```

### Boolean Operators

Booleans interact with several operators, many of which you’ve explored earlier.

1. Comparison Operators
   These produce Boolean results by comparing values.

```sh
a = 10
b = 5
print(a > b)   # Output: True
print(a == b)  # Output: False
print(a <= b)  # Output: False
```

2. Logical Operators
   These combine or modify Boolean values:

and: True if both operands are True.
or: True if at least one operand is True.
not: Reverses the Boolean value.

```sh
x = True
y = False

print(x and y)  # Output: False
print(x or y)   # Output: True
print(not x)    # Output: False
print(not y)    # Output: True
```

3. Identity Operators
   Check if objects are identical, returning a Boolean.

```sh
a = [1, 2]
b = a
c = [1, 2]

print(a is b)      # Output: True (same object)
print(a is c)      # Output: False (different objects)
print(a is not c)  # Output: True
```

4. Membership Operators
   Test presence in sequences, returning a Boolean.

```sh
text = "Python"
print("P" in text)      # Output: True
print("z" not in text)  # Output: True
```

### Boolean Conversion with bool()

The bool() function converts other data types to Boolean values based on their "truthiness":

False Values: 0, 0.0, "" (empty string), [] (empty list), {} (empty dict), () (empty tuple), None, False.
True Values: Non-zero numbers, non-empty strings, non-empty collections, True.

```sh
print(bool(42))        # Output: True
print(bool(-1))        # Output: True
print(bool(0))         # Output: False
print(bool(" "))       # Output: True (non-empty string)
print(bool([]))        # Output: False (empty list)
print(bool([1, 2]))    # Output: True (non-empty list)
print(bool(None))      # Output: False
```

### Booleans as Integers

In Python, Booleans are a subclass of integers:

True equals 1.
False equals 0.
This allows arithmetic operations with Booleans.

```sh
print(True + True)    # Output: 2 (1 + 1)
print(False + True)   # Output: 1 (0 + 1)
print(True * 3)       # Output: 3 (1 * 3)
print(False - 5)      # Output: -5 (0 - 5)
```

### Common Use Cases

Booleans are essential for:

- Conditional Statements
- Loops
- Filtering

### Truthiness in Python

Python evaluates most expressions for their "truthiness" in Boolean contexts (e.g., if statements) without explicit conversion:

Empty or zero values are "falsy."
Non-empty or non-zero values are "truthy."

```sh
if "hello": # Truthy
print("Non-empty string") # Output: Non-empty string

if 0: # Falsy
print("Zero") # No output
else:
print("Not zero") # Output: Not zero

```

---

# List

- [Python List](#python-lists)
- [Creating List](#creating-lists)
- [List Operators](#list-operators)
- [List Indexing and Slicing](#list-indexing-and-slicing)
- [List Mutability](#list-mutability)
- [Common List Method](#common-list-methods)
- [List Comprehension](#list-comprehensions)
- [Common Use Case](#common-use-cases-1)

### Learning Outcomes

By the end of this section, learners will be able to:

- Create and initialize lists with various data types and nested structures.
- Apply operators like +, \*, in, and comparison operators to manipulate and test lists.
- Access and modify list elements using indexing, slicing, and mutability features.
- Use common list methods to add, remove, search, and sort list items.
- Construct lists efficiently using list comprehensions for dynamic data generation.

## Python Lists

Lists in Python are ordered, mutable collections of items that can hold elements of any data type (e.g., numbers, strings, other lists). They are one of the most versatile and widely used data structures in Python, ideal for storing and manipulating sequences of data.

### Creating Lists

Lists are created using square brackets `[]`, with items separated by commas. They can be empty or populated with values.

```sh
# Empty list
empty_list = []

# List with items
numbers = [1, 2, 3, 4]
mixed = [1, "hello", 3.14, True]
nested = [1, [2, 3], 4]

print(numbers)  # Output: [1, 2, 3, 4]
print(type(mixed))  # Output: <class 'list'>
```

#### List Operators

Lists support several operators, many of which overlap with those used for strings and numbers but have specific behaviors with lists.

1. Concatenation (+)
   The + operator combines two lists into a new list.

```sh
list1 = [1, 2]
list2 = [3, 4]
combined = list1 + list2
print(combined)  # Output: [1, 2, 3, 4]
```

2. Repetition (_)
   The _ operator repeats a list a specified number of times.

```sh
list = [1, 2]
repeated = list * 3
print(repeated)  # Output: [1, 2, 1, 2, 1, 2]
```

3. Membership Operators (in, not in)
   These check if an item exists within a list.

```sh
numbers = [1, 2, 3, 4]
print(3 in numbers)      # Output: True
print(5 not in numbers)  # Output: True
print(1 in numbers)      # Output: True
```

4. Comparison Operators (==, !=, >, <, >=, <=)
   Lists can be compared element-by-element lexicographically.

```sh
list1 = [1, 2, 3]
list2 = [1, 2, 4]
print(list1 == list2)  # Output: False
print(list1 < list2)   # Output: True (2 < 4 at first differing position)
print(list1 != list2)  # Output: True
```

### List Indexing and Slicing

Lists are ordered, so you can access elements using indexing (0-based) and extract sublists using slicing.

```sh
numbers = [10, 20, 30, 40, 50]

# Indexing
print(numbers[0])    # Output: 10
print(numbers[-1])   # Output: 50 (last element)

# Slicing [start:stop:step]
print(numbers[1:4])   # Output: [20, 30, 40]
print(numbers[::2])   # Output: [10, 30, 50] (every second element)
print(numbers[::-1])  # Output: [50, 40, 30, 20, 10] (reverse list)
```

### List Mutability

Unlike strings, lists are mutable, meaning you can change their contents after creation.

```sh
numbers = [1, 2, 3]
numbers[0] = 10
print(numbers)  # Output: [10, 2, 3]

# Adding an item
numbers.append(4)
print(numbers)  # Output: [10, 2, 3, 4]
```

### Common List Methods

Python provides a variety of built-in methods for list manipulation. Here are some commonly used ones:

| Method      | Description                                             | Example                                        |
| ----------- | ------------------------------------------------------- | ---------------------------------------------- |
| `append()`  | Adds an item to the end of the list                     | `[1, 2].append(3)` → `[1, 2, 3]`               |
| `extend()`  | Adds all items from an iterable to the list             | `[1, 2].extend([3, 4])` → `[1, 2, 3, 4]`       |
| `insert()`  | Inserts an item at a specified index                    | `[1, 3].insert(1, 2)` → `[1, 2, 3]`            |
| `pop()`     | Removes and returns an item at an index (default: last) | `[1, 2, 3].pop()` → `3`, list becomes `[1, 2]` |
| `remove()`  | Removes the first occurrence of an item                 | `[1, 2, 2].remove(2)` → `[1, 2]`               |
| `clear()`   | Removes all items from the list                         | `[1, 2, 3].clear()` → `[]`                     |
| `index()`   | Returns the index of the first occurrence of an item    | `[1, 2, 3].index(2)` → `1`                     |
| `count()`   | Counts occurrences of an item                           | `[1, 2, 2, 3].count(2)` → `2`                  |
| `sort()`    | Sorts the list in place                                 | `[3, 1, 2].sort()` → `[1, 2, 3]`               |
| `reverse()` | Reverses the list in place                              | `[1, 2, 3].reverse()` → `[3, 2, 1]`            |
| `copy()`    | Returns a shallow copy of the list                      | `[1, 2, 3].copy()` → `[1, 2, 3]`               |

Examples of List Methods

```sh
numbers = [1, 2, 3]

# Length
print(len(numbers))  # Output: 3

# Adding elements
numbers.append(4)
print(numbers)  # Output: [1, 2, 3, 4]

numbers.extend([5, 6])
print(numbers)  # Output: [1, 2, 3, 4, 5, 6]

numbers.insert(0, 0)
print(numbers)  # Output: [0, 1, 2, 3, 4, 5, 6]

# Removing elements
popped = numbers.pop(2)
print(popped)   # Output: 2
print(numbers)  # Output: [0, 1, 3, 4, 5, 6]

numbers.remove(3)
print(numbers)  # Output: [0, 1, 4, 5, 6]

# Searching and counting
print(numbers.index(4))  # Output: 2
print(numbers.count(5))  # Output: 1

# Sorting and reversing
numbers.sort()
print(numbers)  # Output: [0, 1, 4, 5, 6]

numbers.reverse()
print(numbers)  # Output: [6, 5, 4, 1, 0]
```

### List Comprehensions

List comprehensions provide a concise way to create or modify lists.

```sh
# Basic comprehension
squares = [x**2 for x in range(5)]
print(squares)  # Output: [0, 1, 4, 9, 16]

# With condition
evens = [x for x in range(10) if x % 2 == 0]
print(evens)    # Output: [0, 2, 4, 6, 8]
```

### Common Use Cases

Storing Collections:

```sh
fruits = ["apple", "banana", "orange"]
print(fruits[1])  # Output: banana
```

Dynamic Modification:

```sh
tasks = ["learn", "code"]
tasks.append("test")
print(tasks)  # Output: ["learn", "code", "test"]
```

Iteration:

```sh
for num in [1, 2, 3]:
    print(num)  # Output: 1, 2, 3 (one per line)
```

---

# Tuples

- [Python Tuples](#python-tuples)
- [Creating Tuples](#creating-tuples)
- [Tuple Operators](#tuple-operators)
- [Tuple Indexing and Slicing](#tuple-indexing-and-slicing)
- [Tuple Immutability](#tuple-immutability)
- [Common Tuple Methods](#common-tuple-methods)
- [Tuple Packing and Unpacking](#tuple-packing-and-unpacking)
- [Tuple Common Use Cases](#tuple-common-use-cases)
- [Tuples vs. Lists](#tuples-vs-lists)

### Learning Outcomes

By the end of this section, Students will be able to:

- Create and initialize tuples with various data types and understand their immutability.
- Apply operators like +, \*, in, and comparison operators to manipulate and test tuples.
- Access tuple elements using indexing and slicing techniques.
- Use tuple methods (len(), count(), index()) to analyze tuple contents.
- Implement tuple packing and unpacking for efficient data handling.

## Python Tuples

Tuples in Python are ordered, immutable collections of items that can hold elements of any data type (e.g., numbers, strings, other tuples). They are similar to lists but cannot be modified after creation, making them useful for representing fixed collections of data.

### Creating Tuples

Tuples are created using parentheses `()`, with items separated by commas. A single-item tuple requires a trailing comma, and an empty tuple is represented by `()`.

```sh
# Empty tuple
empty_tuple = ()

# Single-item tuple (note the comma)
single_tuple = (42,)

# Multi-item tuple
numbers = (1, 2, 3, 4)
mixed = (1, "hello", 3.14, True)
nested = (1, (2, 3), 4)

print(numbers)      # Output: (1, 2, 3, 4)
print(type(mixed))  # Output: <class 'tuple'>
```

### Tuple Operators

Tuples support several operators, many of which are shared with lists and strings but behave within the context of immutability.

1. Concatenation (+)
   The + operator combines two tuples into a new tuple.

```sh
tuple1 = (1, 2)
tuple2 = (3, 4)
combined = tuple1 + tuple2
print(combined)  # Output: (1, 2, 3, 4)
```

2. Repetition (\*-)
   The \_ operator repeats a tuple a specified number of times.

```sh
tuple = (1, 2)
repeated = tuple * 3
print(repeated)  # Output: (1, 2, 1, 2, 1, 2)
```

3. Membership Operators (in, not in)
   These check if an item exists within a tuple.

```sh
numbers = (1, 2, 3, 4)
print(3 in numbers)      # Output: True
print(5 not in numbers)  # Output: True
print(1 in numbers)      # Output: True
```

4. Comparison Operators (==, !=, >, <, >=, <=)
   Tuples can be compared element-by-element lexicographically.

```sh
tuple1 = (1, 2, 3)
tuple2 = (1, 2, 4)
print(tuple1 == tuple2)  # Output: False
print(tuple1 < tuple2)   # Output: True (3 < 4 at first differing position)
print(tuple1 != tuple2)  # Output: True
```

### Tuple Indexing and Slicing

Tuples are ordered, so you can access elements using indexing (0-based) and extract subtuple using slicing.

```sh
numbers = (10, 20, 30, 40, 50)

# Indexing
print(numbers[0])    # Output: 10
print(numbers[-1])   # Output: 50 (last element)

# Slicing [start:stop:step]
print(numbers[1:4])   # Output: (20, 30, 40)
print(numbers[::2])   # Output: (10, 30, 50) (every second element)
print(numbers[::-1])  # Output: (50, 40, 30, 20, 10) (reverse tuple)
```

### Tuple Immutability

Tuples are immutable, meaning their elements cannot be changed after creation. However, if a tuple contains mutable objects (e.g., lists), those objects can still be modified.

```sh
numbers = (1, 2, 3)
# numbers[0] = 10  # This would raise a TypeError

# Tuple with a mutable object
mixed = (1, [2, 3], 4)
mixed[1][0] = 20
print(mixed)  # Output: (1, [20, 3], 4)
```

### Common Tuple Methods

Tuples in Python are immutable, so they have a limited set of methods compared to lists. Here are the commonly used ones:

| Method    | Description                                          | Example                       |
| --------- | ---------------------------------------------------- | ----------------------------- |
| `count()` | Counts the number of occurrences of an item          | `(1, 2, 2, 3).count(2)` → `2` |
| `index()` | Returns the index of the first occurrence of an item | `(1, 2, 3).index(2)` → `1`    |
| `len()`   | Returns the number of items in the tuple             | `len((1, 2, 3))` → `3`        |

Examples of Tuple Methods

```sh
numbers = (1, 2, 2, 3)

# Length
print(len(numbers))      # Output: 4

# Counting occurrences
print(numbers.count(2))  # Output: 2

# Finding index
print(numbers.index(2))  # Output: 1
```

### Tuple Packing and Unpacking

Tuples support packing (combining values into a tuple) and unpacking (assigning tuple elements to variables).

```sh
# Packing
point = 3, 4  # Parentheses are optional
print(point)  # Output: (3, 4)

# Unpacking
x, y = point
print(x)      # Output: 3
print(y)      # Output: 4

# Unpacking with multiple variables
a, b, c = (1, 2, 3)
print(a, b, c)  # Output: 1 2 3
```

### Tuple Common Use Cases

Fixed Data Storage:

```sh
coordinates = (10, 20)
print(coordinates[0])  # Output: 10
```

Function Return Values:

```sh
def get_min_max(numbers):
    return min(numbers), max(numbers)

result = get_min_max([1, 5, 3])
print(result)  # Output: (1, 5)
```

Dictionary Keys:

```sh
locations = {("NY", "USA"): "New York", ("CA", "USA"): "California"}
print(locations[("NY", "USA")])  # Output: New York
```

### Tuples vs. Lists

| Feature         | Tuple                                                       | List                                                               |
| --------------- | ----------------------------------------------------------- | ------------------------------------------------------------------ |
| **Syntax**      | `()`                                                        | `[]`                                                               |
| **Mutability**  | Immutable (cannot be changed after creation)                | Mutable (can be modified after creation)                           |
| **Methods**     | Fewer: `count()`, `index()`                                 | Many: `append()`, `extend()`, `pop()`, `remove()`, `sort()`, etc.  |
| **Performance** | Slightly faster due to immutability                         | Slightly slower due to mutability overhead                         |
| **Use Case**    | Fixed, unchanging data (e.g., coordinates, records)         | Dynamic, changing data (e.g., growing lists, editable collections) |
| **Size**        | Fixed length                                                | Variable length                                                    |
| **Creation**    | `(1, 2, 3)` or `1, 2, 3` (parentheses optional)             | `[1, 2, 3]`                                                        |
| **Memory**      | Uses less memory                                            | Uses more memory                                                   |
| **Hashability** | Can be used as dictionary keys if all elements are hashable | Cannot be used as dictionary keys (unhashable)                     |

---

# Python Set

- [Python Sets](#python-sets)
- [Creating Set](#creating-sets)
- [Set Operators](#set-operators)
- [Set Properties](#set-properties)
- [Common Set Methods](#common-set-methods)
- [Sets Common Use Cases](#sets-common-use-cases)
- [Sets vs. Lists vs. Tuples](#sets-vs-lists-vs-tuples)

### Learning Outcomes

By the end of this section, learners will be able to:

- Create and initialize sets with unique elements and understand their unordered nature.
- Apply set-specific operators (|, &, -, ^) and membership operators (in, not in) for set operations and testing.
- Use common set methods to add, remove, and perform operations on set elements.
- Differentiate between sets, lists, and tuples based on mutability, order, and uniqueness.
- Implement sets in practical scenarios like removing duplicates and performing mathematical operations.

## Python Sets

Sets in Python are unordered, mutable collections of unique elements. They are designed for efficient membership testing and mathematical set operations (e.g., union, intersection). Sets automatically eliminate duplicates and are ideal for scenarios where uniqueness is key.

### Creating Sets

Sets are created using curly braces `{}` or the `set()` function. An empty set must be created with `set()` since `{}` denotes an empty dictionary.

```sh
# Empty set
empty_set = set()

# Set with items
numbers = {1, 2, 3, 4}
mixed = {1, "hello", 3.14}
duplicates = {1, 2, 2, 3}  # Duplicates are removed

print(numbers)      # Output: {1, 2, 3, 4}
print(duplicates)   # Output: {1, 2, 3}
print(type(mixed))  # Output: <class 'set'>
```

### Set Operators

Sets support operators for mathematical operations, many of which are unique to sets, though some overlap with other types.

1. Union (|)
   Combines all unique elements from two sets.

```sh
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1 | set2
print(union_set)  # Output: {1, 2, 3, 4, 5}
```

2. Intersection (&)
   Returns elements common to both sets.

```sh
set1 = {1, 2, 3}
set2 = {2, 3, 4}
intersection_set = set1 & set2
print(intersection_set)  # Output: {2, 3}
```

3. Difference (-)
   Returns elements in the first set but not in the second.

```sh
set1 = {1, 2, 3}
set2 = {2, 3, 4}
difference_set = set1 - set2
print(difference_set)  # Output: {1}
```

4. Symmetric Difference (^)
   Returns elements in either set but not in both.

```sh
set1 = {1, 2, 3}
set2 = {2, 3, 4}
sym_diff_set = set1 ^ set2
print(sym_diff_set)  # Output: {1, 4}
```

5. Membership Operators (in, not in)
   Check if an element exists in a set (highly efficient).

```sh
numbers = {1, 2, 3, 4}
print(3 in numbers)      # Output: True
print(5 not in numbers)  # Output: True
```

6. Comparison Operators (==, !=, >, <, >=, <=)
   Compare sets for equality or subset/superset relationships.

```sh
set1 = {1, 2}
set2 = {1, 2, 3}
print(set1 == set2)  # Output: False
print(set1 < set2)   # Output: True (set1 is a proper subset of set2)
print(set1 <= set2)  # Output: True (set1 is a subset of set2)
```

### Set Properties

- Unordered: Sets do not maintain insertion order, so indexing and slicing are not possible.
- Mutable: Elements can be added or removed, but the elements themselves must be immutable (e.g., numbers, strings, tuples—not lists or sets).
- Unique: Duplicate elements are automatically removed.

```sh
# No duplicates
set_with_dups = {1, 1, 2, 2, 3}
print(set_with_dups)  # Output: {1, 2, 3}

# Immutable elements only
valid_set = {1, "hello", (2, 3)}
# invalid_set = {1, [2, 3]}  # TypeError: unhashable type: 'list'
```

### Common Set Methods

Python provides a variety of built-in methods for manipulating sets. Here are the commonly used ones:

| Method                   | Description                                       | Example                                             |
| ------------------------ | ------------------------------------------------- | --------------------------------------------------- |
| `add()`                  | Adds an element to the set                        | `{1, 2}.add(3)` → `{1, 2, 3}`                       |
| `update()`               | Adds elements from an iterable                    | `{1, 2}.update([3, 4])` → `{1, 2, 3, 4}`            |
| `remove()`               | Removes an element (raises KeyError if not found) | `{1, 2, 3}.remove(2)` → `{1, 3}`                    |
| `discard()`              | Removes an element (no error if not found)        | `{1, 2}.discard(3)` → `{1, 2}`                      |
| `pop()`                  | Removes and returns an arbitrary element          | `{1, 2, 3}.pop()` → e.g., `2`, set becomes `{1, 3}` |
| `clear()`                | Removes all elements                              | `{1, 2, 3}.clear()` → `set()`                       |
| `union()`                | Returns the union of sets                         | `{1, 2}.union({2, 3})` → `{1, 2, 3}`                |
| `intersection()`         | Returns the intersection of sets                  | `{1, 2}.intersection({2, 3})` → `{2}`               |
| `difference()`           | Returns the difference of sets                    | `{1, 2}.difference({2, 3})` → `{1}`                 |
| `symmetric_difference()` | Returns the symmetric difference                  | `{1, 2}.symmetric_difference({2, 3})` → `{1, 3}`    |
| `issubset()`             | Checks if the set is a subset of another          | `{1, 2}.issubset({1, 2, 3})` → `True`               |
| `issuperset()`           | Checks if the set is a superset of another        | `{1, 2, 3}.issuperset({1, 2})` → `True`             |
| `isdisjoint()`           | Checks if two sets have no common elements        | `{1, 2}.isdisjoint({3, 4})` → `True`                |

Examples of Set Methods

```sh
numbers = {1, 2, 3}

# Adding elements
numbers.add(4)
print(numbers)  # Output: {1, 2, 3, 4}

numbers.update([5, 6])
print(numbers)  # Output: {1, 2, 3, 4, 5, 6}

# Removing elements
numbers.remove(3)
print(numbers)  # Output: {1, 2, 4, 5, 6}

numbers.discard(10)  # No error if 10 isn’t present
print(numbers)  # Output: {1, 2, 4, 5, 6}

popped = numbers.pop()
print(popped)   # Output: e.g., 1 (arbitrary)
print(numbers)  # Output: e.g., {2, 4, 5, 6}

# Set operations
set1 = {1, 2}
set2 = {2, 3}
print(set1.union(set2))         # Output: {1, 2, 3}
print(set1.intersection(set2))  # Output: {2}
print(set1.difference(set2))    # Output: {1}

# Set relationships
print(set1.issubset({1, 2, 3}))  # Output: True
print(set1.isdisjoint({4, 5}))   # Output: True
```

### Sets Common Use Cases

Removing Duplicates:

```sh
lst = [1, 2, 2, 3, 3, 4]
unique = set(lst)
print(unique)  # Output: {1, 2, 3, 4}
```

Membership Testing:

```sh
allowed = {"admin", "user"}
role = "guest"
print(role in allowed)  # Output: False
```

Set Operations:

```sh
a = {1, 2, 3}
b = {2, 3, 4}
common = a & b
print(common)  # Output: {2, 3}
```

### Sets vs. Lists vs. Tuples

| Feature         | Set                                               | List                                      | Tuple                              |
| --------------- | ------------------------------------------------- | ----------------------------------------- | ---------------------------------- |
| **Syntax**      | `{}` or `set()`                                   | `[]`                                      | `()`                               |
| **Order**       | Unordered                                         | Ordered                                   | Ordered                            |
| **Mutability**  | Mutable                                           | Mutable                                   | Immutable                          |
| **Duplicates**  | No duplicates                                     | Allows duplicates                         | Allows duplicates                  |
| **Methods**     | Set operations: `union()`, `intersection()`, etc. | Many: `append()`, `pop()`, `sort()`, etc. | Few: `count()`, `index()`          |
| **Indexing**    | Not supported                                     | Supported                                 | Supported                          |
| **Performance** | Fast membership testing                           | Slower membership testing                 | Moderate performance               |
| **Use Case**    | Unique elements, set operations                   | Ordered, dynamic data                     | Fixed, ordered data                |
| **Hashability** | Unhashable (cannot be dictionary key)             | Unhashable (cannot be dictionary key)     | Hashable if elements are immutable |

---

# Python Dictionary

- [Python Dictionaries](#python-dictionaries)
- [Creating Dictionaries](#creating-dictionaries)
- [Dictionary Operators](#dictionary-operators)
- [Accessing and Modifying Dictionaries](#accessing-and-modifying-dictionaries)
- [Dictionary Properties](#dictionary-properties)
- [Common Dictionary Methods](#common-dictionary-methods)
- [Dictionary Comprehensions](#dictionary-comprehensions)
- [Dictionary Common Use Cases](#dictionary-common-use-cases)
- [Dictionaries vs. Sets vs. Lists vs. Tuples](#dictionaries-vs-sets-vs-lists-vs-tuples)

### Learning Outcomes

By the end of this section, students will be able to:

- Create and initialize dictionaries with key-value pairs and understand their mutability.
- Apply membership operators (in, not in) and comparison operators (==, !=) to dictionaries.
- Access, modify, and add key-value pairs using brackets and methods like get() and update().
- Use common dictionary methods to manipulate and analyze dictionary contents.
- Implement dictionary comprehensions for efficient dictionary creation.

## Python Dictionaries

Dictionaries in Python are unordered, mutable collections of key-value pairs. They are designed for efficient lookups, where each key maps to a value. Keys must be unique and immutable (e.g., strings, numbers, tuples), while values can be of any data type.

### Creating Dictionaries

Dictionaries are created using curly braces `{}` with key-value pairs separated by colons `:`, or the `dict()` function. An empty dictionary is represented by `{}`.

```sh
# Empty dictionary
empty_dict = {}

# Dictionary with items
numbers = {"one": 1, "two": 2, "three": 3}
mixed = {"name": "Alice", "age": 25, "active": True}
nested = {"person": {"name": "Bob", "age": 30}}

print(numbers)      # Output: {'one': 1, 'two': 2, 'three': 3}
print(type(mixed))  # Output: <class 'dict'>
```

### Dictionary Operators

Dictionaries support a limited set of operators compared to sequences, focusing on membership and basic comparisons.

1. Membership Operators (in, not in)
   Check if a key exists in the dictionary (not values).

```sh
numbers = {"one": 1, "two": 2}
print("one" in numbers)      # Output: True
print("three" not in numbers)  # Output: True
print(1 in numbers)          # Output: False (checks keys, not values)
```

2. Comparison Operators (==, !=)
   Compare dictionaries for equality (order doesn’t matter).

```sh
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 2, "a": 1}
dict3 = {"a": 1, "b": 3}
print(dict1 == dict2)  # Output: True (same key-value pairs)
print(dict1 != dict3)  # Output: True (different values)
```

### Accessing and Modifying Dictionaries

Dictionaries use keys to access and modify values. Square brackets [] or the get() method retrieve values, while assignment updates or adds entries.

```sh
person = {"name": "Alice", "age": 25}

# Accessing values
print(person["name"])      # Output: Alice
print(person.get("age"))   # Output: 25
print(person.get("city", "N/A"))  # Output: N/A (default if key not found)

# Modifying values
person["age"] = 26
print(person)  # Output: {'name': 'Alice', 'age': 26}

# Adding new key-value pair
person["city"] = "New York"
print(person)  # Output: {'name': 'Alice', 'age': 26, 'city': 'New York'}
```

### Dictionary Properties

- Unordered: Prior to Python 3.7, dictionaries were unordered; since 3.7, they preserve insertion order (though this is an implementation detail, not a core feature).
- Mutable: Key-value pairs can be added, modified, or removed.
- Unique Keys: Duplicate keys are not allowed; the last value overwrites earlier ones.
- Immutable Keys: Keys must be hashable (e.g., strings, numbers, tuples), but values can be any type.

```sh
# Duplicate keys
dict_with_dups = {"a": 1, "a": 2}
print(dict_with_dups)  # Output: {'a': 2}

# Valid keys
valid_dict = {1: "one", "two": 2, (3, 4): "tuple"}
# invalid_dict = {[1, 2]: "list"}  # TypeError: unhashable type: 'list'
```

### Common Dictionary Methods

Python provides a variety of built-in methods for manipulating dictionaries. Here are the commonly used ones:

| Method         | Description                                             | Example                                                              |
| -------------- | ------------------------------------------------------- | -------------------------------------------------------------------- |
| `keys()`       | Returns a view of all keys                              | `{"a": 1}.keys()` → `dict_keys(['a'])`                               |
| `values()`     | Returns a view of all values                            | `{"a": 1}.values()` → `dict_values([1])`                             |
| `items()`      | Returns a view of all key-value pairs                   | `{"a": 1}.items()` → `dict_items([('a', 1)])`                        |
| `get()`        | Returns value for a key, or a default                   | `{"a": 1}.get("b", 0)` → `0`                                         |
| `pop()`        | Removes and returns value for a key                     | `{"a": 1}.pop("a")` → `1`, dict becomes `{}`                         |
| `popitem()`    | Removes and returns the last key-value pair             | `{"a": 1, "b": 2}.popitem()` → `('b', 2)`                            |
| `update()`     | Updates dict with key-value pairs from another          | `{"a": 1}.update({"b": 2})` → `{"a": 1, "b": 2}`                     |
| `clear()`      | Removes all key-value pairs                             | `{"a": 1}.clear()` → `{}`                                            |
| `copy()`       | Returns a shallow copy of the dictionary                | `{"a": 1}.copy()` → `{"a": 1}`                                       |
| `setdefault()` | Returns value if key exists, else adds key with default | `{"a": 1}.setdefault("b", 0)` → `0`, dict becomes `{"a": 1, "b": 0}` |

Examples of Dictionary Methods

```sh
person = {"name": "Alice", "age": 25}

# Views
print(person.keys())    # Output: dict_keys(['name', 'age'])
print(person.values())  # Output: dict_values(['Alice', 25])
print(person.items())   # Output: dict_items([('name', 'Alice'), ('age', 25)])

# Get with default
print(person.get("city", "Unknown"))  # Output: Unknown

# Removing items
age = person.pop("age")
print(age)      # Output: 25
print(person)   # Output: {'name': 'Alice'}

last_item = person.popitem()
print(last_item)  # Output: ('name', 'Alice')
print(person)     # Output: {}

# Updating
person.update({"name": "Bob", "age": 30})
print(person)  # Output: {'name': 'Bob', 'age': 30}

# Setdefault
person.setdefault("city", "New York")
print(person)  # Output: {'name': 'Bob', 'age': 30, 'city': 'New York'}
```

### Dictionary Comprehensions

Dictionary comprehensions provide a concise way to create dictionaries.

```sh
# Basic comprehension
squares = {x: x**2 for x in range(4)}
print(squares)  # Output: {0: 0, 1: 1, 2: 4, 3: 9}

# With condition
evens = {x: x**2 for x in range(6) if x % 2 == 0}
print(evens)    # Output: {0: 0, 2: 4, 4: 16}
```

### Dictionary Common Use Cases

Key-Value Storage:

```sh
student = {"name": "Alice", "grade": "A"}
print(student["name"])  # Output: Alice
```

Counting Occurrences:

```sh
letters = "hello"
counts = {}
for char in letters:
    counts[char] = counts.get(char, 0) + 1
print(counts)  # Output: {'h': 1, 'e': 1, 'l': 2, 'o': 1}
```

Configuration Data:

```sh
config = {"host": "localhost", "port": 8080}
print(config["port"])  # Output: 8080
```

### Dictionaries vs. Sets vs. Lists vs. Tuples

| Feature         | Dictionary                            | Set                               | List                                | Tuple                              |
| --------------- | ------------------------------------- | --------------------------------- | ----------------------------------- | ---------------------------------- |
| **Syntax**      | `{key: value}`                        | `{}` or `set()`                   | `[]`                                | `()`                               |
| **Order**       | Ordered (since 3.7)                   | Unordered                         | Ordered                             | Ordered                            |
| **Mutability**  | Mutable                               | Mutable                           | Mutable                             | Immutable                          |
| **Duplicates**  | Unique keys                           | No duplicates                     | Allows duplicates                   | Allows duplicates                  |
| **Access**      | By key                                | No indexing                       | By index                            | By index                           |
| **Methods**     | `keys()`, `values()`, `items()`, etc. | `union()`, `intersection()`, etc. | `append()`, `pop()`, `sort()`, etc. | `count()`, `index()`               |
| **Performance** | Fast key lookups                      | Fast membership testing           | Slower membership testing           | Moderate performance               |
| **Use Case**    | Key-value mappings                    | Unique elements, set operations   | Ordered, dynamic data               | Fixed, ordered data                |
| **Hashability** | Unhashable                            | Unhashable                        | Unhashable                          | Hashable if elements are immutable |

---

```

```
