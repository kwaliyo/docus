# Modules in Python

- [Modules in Python](#modules-in-python)
- [What is a module?](#what-is-a-module)
- [Example of Simple Module](#example-of-a-simple-module)
- [Importing Module](#importing-modules)
- [Built-in Modules](#built-in-modules)
- [Creating and Using Custom Modules](#creating-and-using-custom-modules)
- [Packages](#packages)
- [Reloading Modules](#reloading-modules)
- [Modules and Operators](#modules-and-operators)
- [Common Use Cases](#common-use-cases)
- [Modules vs. Scripts](#modules-vs-scripts)

Learning Outcomes
By the end of this section, students will be able to:

- Create and use custom modules to organize Python code.
- Import built-in and custom modules using various techniques (import, from ... import, aliasing).
- Understand Python’s module search path and package structure.
- Apply operators within module functions for reusable logic.
- Differentiate between running a file as a module vs. a script.

# Modules in Python

Modules in Python are files containing Python code (e.g., functions, classes, variables) that can be imported and reused in other programs. They help organize code, promote reusability, and manage namespaces. Python’s standard library includes many built-in modules, and you can create your own custom modules.

## What is a Module?

A module is simply a `.py` file with Python definitions. When imported, its contents become available in your program under the module’s namespace.

### Example of a Simple Module

Create a file named `math_utils.py`:

```python
# math_utils.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

PI = 3.14159
```

### Importing Modules

Use the import statement to bring a module’s contents into your program.

1. Basic Import

```py
import math_utils

result = math_utils.add(5, 3)
print(result)  # Output: 8
print(math_utils.PI)  # Output: 3.14159
```

2. Importing Specific Items
   > Use from ... import ... to import specific functions, classes, or variables.

```py
from math_utils import add, PI

print(add(10, 2))  # Output: 12
print(PI)          # Output: 3.14159
```

3. Importing Everything
   > Use from ... import \* to import all items (not recommended due to namespace pollution).

```py
from math_utils import *

print(add(4, 6))      # Output: 10
print(subtract(8, 3)) # Output: 5
print(PI)             # Output: 3.14159
```

4. Aliasing
   Use as to give a module or item a shorter or more convenient name.

```py
import math_utils as mu

print(mu.add(7, 1))  # Output: 8
```

### Built-in Modules

Python’s standard library provides many useful modules.

```py
Examples
#math Module:
import math

print(math.sqrt(16))  # Output: 4.0
print(math.pi)        # Output: 3.141592653589793

#os Module:
import os

print(os.getcwd())  # Output: Current working directory path
# random Module:
import random
print(random.randint(1, 10))  # Output: Random integer between 1 and 10
```

### Creating and Using Custom Modules

Example: Custom Module
Create a file geometry.py:

```py
# geometry.py
def circle_area(radius):
    import math  # Local import
    return math.pi * radius ** 2

def rectangle_area(width, height):
    return width * height

class Shape:
    def __init__(self, name):
        self.name = name
```

Use it in another file (e.g., main.py):

```py
# main.py
import geometry

print(geometry.circle_area(5))      # Output: 78.53981633974483
print(geometry.rectangle_area(4, 3)) # Output: 12

shape = geometry.Shape("Triangle")
print(shape.name)                    # Output: Triangle
```

Module Search Path
Python looks for modules in:

- The current directory.
- Directories listed in the PYTHONPATH environment variable (if set).
- Standard library directories.
  Check the search path:

```py
import sys
print(sys.path)  # List of directories Python searches
```

### Packages

A package is a directory containing multiple modules and an **init**.py file (can be empty). It allows hierarchical organization.

Example Package Structure

my_package/
├── **init**.py
├── module1.py
└── module2.py
module1.py:

```py
def func1():
    return "Function 1"
```

module2.py:

```py
def func2():
    return "Function 2"
```

Using the package:

```py
from my_package import module1, module2

print(module1.func1())  # Output: Function 1
print(module2.func2())  # Output: Function 2
```

### Reloading Modules

Modules are cached after import. Use importlib.reload() to reload a module if it changes during execution.

```py
import math_utils
import importlib

# Modify math_utils.py externally, then:
importlib.reload(math_utils)
print(math_utils.add(2, 3))  # Reflects updated code
```

### Modules and Operators

Modules often use operators internally or expose functions that do:

```py
# math_utils.py with operators
def multiply(a, b):
    return a * b

# main.py
import math_utils

print(math_utils.multiply(4, 5))  # Output: 20
```

### Common Use Cases

Code Organization:

```py
# utils.py
def greet(name):
    return f"Hello, {name}!"

# main.py
from utils import greet
print(greet("Alice"))  # Output: Hello, Alice!
```

Reusing Code:

```py
# calculations.py
def square(n):
    return n * n

# main.py
from calculations import square
print(square(5))  # Output: 25
```

Extending Functionality:

```py
import datetime

today = datetime.date.today()
print(today)  # Output: e.g., 2025-03-14
```

### Modules vs. Scripts

| Aspect        | Module                    | Script               |
| ------------- | ------------------------- | -------------------- |
| **Purpose**   | Reusable code             | Standalone execution |
| **Execution** | Imported into other files | Run directly         |
| **Example**   | `math_utils.py`           | `main.py`            |

```py
# math_utils.py
def add(a, b):
    return a + b

if __name__ == "__main__":
    print("Running as script")
    print(add(2, 3))  # Output: 5
When imported: __name__ is the module name (math_utils).
When run directly: __name__ is "__main__".
```

```py
python math_utils.py
# Output:
# Running as script
# 5
```
